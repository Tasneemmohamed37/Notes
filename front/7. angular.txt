https://www.youtube.com/playlist?list=PLesfn4TAj57WJFn86KXOInQAsCdJlp6vl

--------------------- [ session 01 ] ---------------------

- angular -> front-end framework
		  -> SPA
		  -> component based [ page contain of components ]
		  -> use MVC arch pattern 
		  -> 1. install npm
		  -> 2. install angular $[npm install -g @angular/cli ]
		  -> 3. in specific folder $[ ng new projectName ]
		  -> 4. in project terminal $[ npm start || ng serve ]

- project structure -> node modules -> contain all modules or packages which are built in or installed 
					-> package.json -> contain all dependencies name and version 
					-> tsConfig.json -> contain cofig used to combine from ts to js 
					-> build -> contain outPath 'files produced from compilation'
					-> index.html -> the only file in the project can type js in it & link this with style using file 'angular.json'
					-> main.js -> contain two func -> bootstrap module 'eager loaded module' -> decide first module to run 'appModule' 
												   -> platform browser dynamic -> use 'polyfiles' based on defualt used browser 
					-> appModule.ts -> contain 4 arrays -> declarations -> contain all components of this module 
														-> imports -> in case want to use any other module
														-> provider -> service providers
														-> bootstrap -> first component to run, for sure this component name found in declarations
					-> appComponent.ts -> contain of -> selctor 
													 -> templetUrl 'html'
													 -> styleUrls

- module contain of many components

- selector -> component directive 'angular tags' used to call component
												   
- project life cycle -> index / main.js / appModule / bootstrap component 'appComponent' / appComponent.ts / selector <app-root> / appComponent.html  

- Decorator design pattern is used to modify the functionality of an object at runtime like '@ngModule' which used with class to make it module

- can send in header request some data like [ content type - token ]

- to install bootstrap -> 1. $[ npm i bootstrap ]
					   -> 2. in file 'angular.json' add style $[ node_modules/bootstrap/dist/css/bootstrap.min.css ] and scripts $[ node_modules/bootstrap/dist/js/bootstrap.bundle.min.js ]
					   
- prob -> in angular can write js only in file index , but what about bootstrap???
  solve -> install angular material 
  
- to add new component -> 1. in src/components open new terminal $[ ng g c component_name --skip-tests ]
					   -> 2. add this selector to appComponent.html 
					   
- structure directive -> $[ *ngFor='let i of arr' ]



--------------------- [ session 02 ] ---------------------

- Data Binding -> one way -> from ts to html -> interpolation {{}} 
											 -> prop binding $[ <img [src]="item.url">] -> between double quests prop will replaced with this value
						  -> from html to ts -> event binding
			   -> two way -> require adding formModules in imports 
			   
- event binding -> when spec event fire in html, call func in ts 
				-> 1. pass primitive data -> $[ <button (click)="printMsg('hello')"></button>]
				-> 2. templete var, pass element using ref -> $[ <input #itemCount> <button (click)="buy(itemCount)"></button>]  note!!! can only use throw html file
				-> 3. pass event args -> $[ <button (click)="printBtn($event)"></button>  printBtn(x:any){x.target.innerHtml = 'lol'}]
				-> 4. view child -> decorator include spec element in html page using tempelte var, can use this element in ts file as you like 'use it instead of doc.getElementByID'
								 -> $[
										<div #divViewChild></div>
										@viewChild(divViewChild) dvc:any
										ngAfterViewInit(): void {
										this.dvc.nativeElement.innerHtml = ''
										}
									]	
									
- two way binding -> 1. normal way -> event + interpolation
				  -> 2. forms module -> 1. inside appModule import formsModule
									 -> 2. each input field must have name
									 -> 3. declare var in ts file 
									 -> 4. in html [(ngModel)] = var 
									 
- $[class.d-none]="prd.categoryID!=selectedCatId" -> use prop bindig to apply spec class 

- Directives -> 1. component directive -> directive with a tempelte 'use class selector'
			 -> 2. structure directive -> change layout of the elements [ngIf - ngIfElse - ngFor - ngSwich]
									   -> can`t use two structure directive with the same element, can solve this using ngContainer 
			 -> 3. attribute directive -> change the apperence or behaivur of particular element [ngClass - ngStyle - ngModel]
			 
- trackBy function -> used to specify iterable objects identity, and so enhance the performance of ngFor in case of change to the collection, and update changed object without re-build the DOM 
				   -> $[ 
						*ngFor="let prd of prdList; let i = index; trackBy:prdTrackByFunc"
					     prdTrackByFunc(index:number, prd:IProduct):number{return prd.id ;}
					   ]

- in case want to filter collection based on spec condition, what is the best performance,use structure directive 'ngIf' or prop bindig '[class.d-none]="prd.categoryID!=selectedCatId"'??
					-- prop binding is best performance, becouse structure directive in run time will remove element from DOM then reload DOM
					
- ngTemplete VS ngContainer -> ngTemplete only work with structure tempelte, but ngContainer by defualt show element but the major benfite that it don`t add element to DOM 

- customer directive -> 1. $[ ng g directive lightBox ]
					 -> 2. in directive ts file ctor $[ constructor(eleRef: ElementRef){eleRef.nativeElement.style.border = '1px solid red';} ]
					 -> 3. add this class selctor to any html element $[lightBox='red']  NOTE!! in case write [lightBox]='readFromPropInTs'
					 
- @hostListener -> is function decorator used to execute function when fire spec event 

--------------------- [ session 03 ] ---------------------

- pipes -> functions used to accept an input value [strings, currency amounts, dates, other dt] separete with ' | ' and return a transformed value.
		-> $[ {{prd.price | currency}} ]
		
- component lifecycle -> 1. ctor => use it in var init | DI
					  -> 2. ngOnChange => call it every time component input decorator params changes [used it when send data from parent to child]
					  -> 3. ngOnInit => connect with api & use service بضيف فيه اي حاجة عايزها تحصل اول ما الكومبوننت يفتح 
					  -> 4. ngAfterViewInit => use it in viewChild
					  -> 5. ngOnDestroy  => close api connection & unsubscribe to observable
					   
- color='red' --> will take value direct
  [color]='red' --> will take value of prop red	

  
- component interAction -> 1. from parent to child -> 1. add child selector into parent html
												   -> 2. inside parent ts file add var $[parentData: string = "from parent";]
												   -> 3. inside child ts add var with decorator '@Input()' to store parent var on it  $[@Input() childData: string = "";]
												   -> 4. in parent html inside child selctor add prop binding $[<app-child [childData]="parentData"></app-child>]
						
						-> 2. from child to parent -> 1. in child ts add var contain data $[childData: string = "sent from child";]
												   -> 2. in child ts add event with declare '@Output()' to send data out side component $[ @Output() myEvent: EventEmitter<string> = new EventEmitter<string>(); ]  note!! import EventEmitter from '@angular/core'
												   -> 3. in child ts emitting event (when click on button || inside ngOnInit) $[ SendData(){ this.myEvent.emit(childData);}]
												   -> 4. in parent html inside child selctor bind on event to get data $[ <app-child (myEvent)="getData($event)"></app-child>]
												   -> 5. implement parent function and save data in component var $[getData(childMsg:string){}]
												   												   
										
- x!: elementRef -> non-null asseration operator  ==> to define this element impossible will be null 
										
- so now we can use any thing inside child in parent use two ways [ @Output | viewChild ] so what different between them?? 
											-> @Output -> use in case there is an event happen
											-> viewChild -> can use it any time 
											
											
--------------------- [ session 04 ] ---------------------

- service -> contain all business logic of component
		  -> 1. $[ ng g s ay7aga --skip-tests ] and add crud operations inside this file 
		  -> 2. inject this service in component ctor then can use it inside 'onInit()'
		  -> in service file found "providedIn:" -> 'root' -> apply singleton design pattern on service
												 -> 'any' -> eager loaded modules share singleton instance however lazy loaded modules get there own unique instance 
												 -> 'module_name' 

- dependency injection -> used to remove hard code depencency 
					   -> can inject using [ ctor | method | prop ]
					  
- routing -> 1. inside file 'app.routes.ts' add paths in routes array $[{path: 'Home', component: HomeComponent} ]  note!!! path name is case sensetave
		  -> note that arrange of routes array importent!! so must start with defualt path $[{path: '', redirectTo: '/home', pathMatch:'full'}] and end with wild card $[ {path:'**', component:NotFoundComponent}]
		  -> 2. inside appComponent.html add $[ <router-outlet></router-outlet> ]
		  -> 3. add the RouterLink, RouterLinkActive, and RouterOutlet to the imports array of AppComponent.
		  -> 4. use routing by add $[ [routerLink]='/Home'] in html file to make it absolute path  and $[routerLinkActive="active"] to apply active class 
		  
- to use defferent layouts use child routes in file 'app.routes.ts' $[ 
																		export const routes: Routes = [
																			{path: '', component: MainLayoutComponent,children:[
																				{path: '', redirectTo: '/home', pathMatch:'full'},
																				{path: 'home', component: HomeComponent},
																				{path: 'products', component: ProductsListComponent},
																				{path: 'order', component: OrderMasterComponent},
																			]},
																			{path: 'login', component: LoginComponent},
																			{path:'**', component:NotFoundComponent} // wild card path
																		];
																		]
																		
																		
- to attach id to url -> 1. inside ctor inject route service $[ constructor(private router: Router){}]
					  -> 2. $[this.router.navigate(['/products',prdId]);]

- to get id from url -> 1. inside ctor inject active route service $[ constructor(private activatedRouter:ActivatedRoute){}]
					 -> 2. $[ this.activatedRouter.snapshot.params['id']; ]
					 
- so to navigate to specific url -> in ts use 'Router'
								 -> in html use 'routerLinkActive'