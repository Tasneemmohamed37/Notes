
- sql dt -> 1. numeric [bit - int - smallint - bigint..]
		 -> 2. fractions [money - float - dec]
		 -> 3. string [char - varchar - nvarchar] -> CHAR(10) store "hello", will still take up 10 characters of storage space, regardless of the actual length of the string you store in it, use it when you have fixed-length data, such as postal codes or certain types of identifiers.
												  -> VARCHAR(10) store "hello", will only take up 5 characters of storage space.
												  -> n == unicode , used when you need to store characters from multiple languages

- variables -> local $[ @age int = 3]
			-> global $[ select @@ServerName ]

- before any thing must select database first $[use db_name]
	
- to add fk use keyword 'reference'
	
- sql -> 1. DDL "Data Definition Language" interacte with metadata & structure [crate table|view|function - alter - drop - rename - trancate'delete without where']
	  -> 2. DML "Data Manpulation Language" interacte with data [insert - update - delete - select into] 
	  -> 3. DQL "Data Query Language" display data [select - aggFunc - grouping - union - joins - subqueries]
	  -> 4. DCL "Data Control Language" security & permissions [grant - deny - revoke]
	  -> 5. TCL "Transaction Control Language" execution [commit - rollback]

- sql patterns -> _ => one Char
				  % => Zero or More Chars
				  'a%h' ah aghjklh
				  '%a_' ak hjkak
				  '[ahm]%' amr hassan mohamed a
				  '[^ahm]%' Esraa Fatma Sara Ø§Ù‰ Ø­Ø±Ù ØºÙŠØ± Ø§Ù„ Ø§ÙŠ Ø§Ùˆ Ø§Ù„Ø§ØªØ´ Ø§Ùˆ Ø§Ù„Ø§Ù…
				  '[a-h]%' Ø§Ù„Ø­Ø±ÙˆÙ Ù…Ù† Ø§Ù„ Ø§ÙŠÙ‡ Ø§Ù„Ù‰ Ø§Ù„Ø§ØªØ´
				  '[^a-h]%' Ø§Ù„Ø­Ø±ÙˆÙ Ø§Ù„Ù‰ Ù…Ø´ Ù…Ù† Ø§Ù„ Ø§ÙŠÙ‡ Ø§Ù„Ù‰ Ø§Ù„Ø§ØªØ´
				  '[346]%' Ø¬Ù…Ù„Ø© ØªØ¨Ø¯Ø£ Ø¨ Ø§ÙŠ Ø±Ù‚Ù… Ù…Ù† Ø¯ÙˆÙ„
				  '%[%]' ghjkl%
				  Ø§Ø³ØªØ®Ø¯Ù…Ù†Ø§ Ø§Ù„Ø¨Ø±Ø§ÙƒØªØ³ Ø¹Ø´Ø§Ù† Ù†Ù‚ÙˆÙ„Ù‡ Ø§Ù† Ø¹Ù„Ø§Ù…Ø© Ø§Ù„Ø¨ÙŠØ±Ø³Ù†Øª Ø¯ÙŠ Ø§Ùˆ _ Ø§Ø­Ù†Ø§ Ø¹Ø§ÙŠØ²ÙŠÙ† Ù†Ø³Ù„ÙƒØªÙ‡Ø§ Ù„Ø§Ù†Ù‡Ø§ Ù…Ø­Ø¬ÙˆØ²Ø© ÙÙ‰ Ø§Ù„Ù„ØºØ©
				  '%[_]%' Ahmed_Ali _
				  '[_]%[_]' _Ahmed_
				  
- Distinct -> Ù„Ùˆ Ø¹Ù†Ø¯Ù‰ Ø§ÙƒØªØ± Ù…Ù† Ø­Ø§Ø¬Ø© Ù…ÙƒØ±Ø±Ø© Ù‡Ø³ØªØ®Ø¯Ù… Ø¯ÙŠØ³ØªÙ†ÙƒØª Ù„ØªÙØ§Ø¯Ù‰ Ø§Ù„ØªÙƒØ±Ø§Ø±

- joins -> 1. Cross join (Cartisian Product) -> commonly used to generate as we can to test
		-> 2. Inner Join (Equi Join) 'two parts musn't be null' 
		-> 3. Outer Join -> 3.1 Left Outer Join 'select all data in left table which is not null'
						 -> 3.2 Right Outer Join
						 -> 3.3 Full Outer Join
		-> 4. Self Join
		


- Built-in Functions -> 1. Aggregate Functions 'Scalar Functions' [count - sum - avg - min - max] Return Only One Value which Not Existed In Database    note!!! If You Select Columns With Aggregate Functions,You Must Group By With The Same Columns
					 -> 2. Null Functions [IsNull - Coalesce]
					 -> 3. Casting Functions [convert - cast - format]
	
	
- groupBy -> You Can't Group By With * or PK
		  -> We Grouping With Repeated Value Column

		  
- You Can't Use Agg Functions Inside Where Clause but can use it only in case of subquery 
	not valid âŒ							validâœ”								validâœ”	
	select Sum(Salary)						select Sum(Salary)					select Super.St_FName, Count(Stud.St_Id)
	from Instructor							from Instructor						from Student Stud, Student Super
	where count(Ins_Id) < 100				having count(Ins_Id) < 100			where Super.St_Id = Stud.St_Super
																				group by Super.St_FName
									
	

- having -> used with groupBy or aggFunc 

- Sub Query -> Output Of Sub Query[Inner] As Input To Another Query[Outer]
			-> SubQuery Is Very Slow (Not Recommended Except Some Cases) Ø¨Ø·Ø¦ Ø¬Ø¯Ø§
			-> Ø§Ø³ØªØ®Ø¯Ù…Ù‡ ÙÙ‰ Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ù„Ù‰ Ø²ÙŠ Ø§Ù„Ù„Ù‰ ØªØ­Øª Ø¯ÙŠ
			-> 1 Ù„Ùˆ Ø§Ù†Ø§ Ø¹Ø§ÙŠØ² Ø§Ø¹Ù…Ù„ ÙƒÙˆÙ†Ø¯Ø´Ù† Ø¨Ø§Ù„Ø§Ø¬Ø±ÙŠØ¬ÙŠØª ÙØ§Ù†ÙƒØ´Ù† Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙˆÙŠØ± -
			-> 2 Ù„Ùˆ Ø§Ù†Ø§ Ø¹Ø§ÙŠØ² Ø§Ø³Ù„ÙŠÙƒØª Ø§Ø¬Ø±Ø¬ÙŠØ¬Øª ÙØ§Ù†ÙƒØ´Ù† ÙˆØ§Ù†Ø§ Ù…Ø´ Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø±ÙˆØ¨ Ø¨Ø§ÙŠ


- execution order -> from
				  -> join
				  -> on 'used with join instead of where'
				  -> where
				  -> group by
				  -> having
				  -> select
				  -> order by
				  -> top
				  

- Schema ->  logical view of the entire database. It defines how data is organized and how relations among them are associated.
		 -> used to solve some prob -> 1. You Can't Create Object With The Same Name [Table, View, Index, Trigger, Stored Procedure, Rule]
									-> 2. There Is No Logical Meaning (Logical Name)
									-> 3. Permissions
		 -> Default Schema -> DBO 'Database Owner'

		 
- Union Family -> combine result sets of two or more SELECT into a single result set | merge results of two or more queries into a single result set
			   -> Have 2 Conditions Columns must have The Same [ Datatype & numbers ]
			   -> union all 'with duplication'
			   -> union 'without duplication'
			   -> intersect 
			   -> except 
				
- view -> virtual table contain result set of a SELECT query [variable contain query and when call it execute query and return result in virtual table]
	   -> Unlike a physical table, a view does not store data itself; instead, it dynamically retrieves data from one or more underlying tables whenever the view is queried.
	   -> used for [Simplifying Complex Queries - Data Security - Data Abstraction - Reusability]

- view VS function -> functions are used to encapsulate logic and perform calculations [can take a parameters],
				   -> views just display and used to simplify query complexity and provide a virtual representation of data.

- drop -> delete table it self 'ddl'
  delete -> delete rows from a table based on specified conditions 'dml'
  trancate -> delete all rows 'ddl' & cannot be rolled back using a transaction


- stored procedure ğŸ†š user defined function?
	stored procedure -> return Zero or n values   												function -> Return only one value, which is mandatory
					 -> have input/output parameters						 						 	 -> only input parameters
					 -> Allows DML(Data manipulation language 'select, insert, update, delete') 	     -> Allows only select statements
					 -> can call function																 -> can`t call procedure
					 

- trigger -> Special Stored Procedure
		  -> Can't call or take parameters
		  -> can handle it using [Drop | Disable | Enable]
		  -> types -> 1. Server Level
				   -> 2. DB Level
				   -> 3. Table Level (events)
					
					
- clustered index -> detect table order in table itself 		 		     non clustered index -> arrang table in memory
					-> only one 'PK by defualt' 		 				 						 -> up to 999 'uniqe by defualt'
					-> Last Level Is The Actual Data 											 -> Last Level Is The Actual Data
					-> faster , use binary search 
	