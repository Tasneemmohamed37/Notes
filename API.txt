----------------------- [session 01 ] --------------------

------------ [ 1.1 ]
- miniaml APIs -> end points without controller
- in API handel routing in each controller unLike mvc handel it once in program file
- appsetting -> include setting per invironment [dev | test | staging | production]
- restful API -> can execute endPoint only with [controller name + verb]
- middelware app.Mapcontroller() -> work like [app.useRouting "match request to endPoints" + app.useEndPoints "execute matching endPoint"]

------------ [ 1.3 ]
- graphQL -> minimize the number of requests and responses.


------------ [ 1.4 ]
- Union Arch -> 1. Domain layer [domain models - all Interfaces] 
					also name as core layer becouse it contain all project but not implemented
			 -> 2. Repository layer [repos - DbContext - fluentAPI - ]	
			 -> 3. Service layer [ payment service - cashing service - order service - auth service]
			 -> 4. Persentation layer [ controlles - DTOs ]

------------ [ 1.5 ]
- rel between product & category is 1:M but in case we make one nav prop in product only this rel will be 1:1 so must use fluentAPI
			 
------------ [ 1.6 ]
- packages -> sql   :repo layer [context] 
		   -> tools : PL [connection string]
		   

- references -> API -> repo
			 -> repo -> core
			 -> 
			 
- to apply fluentAPI using class -> class:IentityTypeConfiguration
								 -> override onModelCreating then apply configuration from assembly to apply all classes [ REFLECTION ]

------------ [ 1.7 ]
update database using obj from dbContext => 1. every time run project apply all migrations which wasn`t apply
										 => 2. use this context obj in data seeding
										 => steps -> in program class after builder.build create obj from dbcontext  by Ask Explicitly [ create scope - services - context obj - migrateAsnc]

----------- [ 1.8 ]
- data seeding -> read json files then desrialize 'convert from json' to list of this data type then add it to DB finally save changes

----------- [ 1.9 ]
- find => search local first if not found then search remote

----------- [ 1.11 ]
- by defualt nav prop not load , can load it using one of 3 approaches -> explicite [ .load ]
																	   -> eager loading [ Include ]
																	   -> lazy load [ proxies package ]


---------------------------------------------------- [ Session 02 ] --------------------------------------------

--------- [ 2.1 ]

- specification design pattern => used to build dynamic queries 
							   => من غيرة كان عندنا مشكلة وهي في الجينيرك ريبو لما كان نحتاج نعمل انكلود للنافجيشن بروبرتي كنا بنضطر نشتغل ب مسكن ونعمل اكتر من كونديشن للتايب اللي هنشتغل عليه 
							   => steps -> 1. detecte query components [ex : inputQuery '$ _dbContext.set<T>' / where condition / list of includes ]
										-> 2. ISpecification interface include prop signiture for each query component
										-> 3. baseSpecification class implement this interface and contain auto prop 
										-> 4. specificationEvaluator class include function build query by take as a parameter [inputQuery , ISpecification ]
										-> 5. generic repo work with function which build query 
										-> 6. for each entity with includes make class inhirate from baseSpecification , condition 2 ctors one with criteria and other without 
										-> 7. in controllers create obj from class in step 6 to create spec 
										
										
- aggregate =>  accumirate over sequence
			=> ex : $ string[] names = ["tasneem" , "mohamed" , "elhussiny"]
					$ string msg = 'hello'
					$ msg = names.aggregate(msg , (str1 , str2) => $"{str1} {str2}" );
					result ==> hello tasneem mohamed elhussiny
					
---------- [ 2.4 ]

- prob -> retreved data contain nested obj [data of product include data of nav props] , and want make it flat 
- solve -> DTO [data to obj] in api layer 
		-> auto mapper package in api layer
		-> in controller ctor inject Imapper
		-> in program file allow DI for auto mapper  $ builder.Services.AddAutoMapper(typeof(mappingProfiles)); [work transiant becouse for sure in one request need to map only one time ]
		-> class mappingProfiles which include map for all profiles in his ctor and inhirate from profile class 
		-> in end point map [ $ _autoMapper.Map<S,D>(S data)]
		

----------- [ 2.5 ]

- resolve pic url -> inside helpers folder add class productPicUrlResolve which inhirate form class 'Ivalue resolver<S,D,SMemberDataType>'
				  -> inside appSetting add baseUrl
				  -> in class mappingProfiles add for product map [ $ForMember(d => d.PictureURL , O => O.MapFrom<productPictureUrlResolve>())]
				  -> in program class use middelware '$ app.useStaticFiles'
				  
------------ [ 2.7 ]

- null coalescing operator '??'  => x = y ?? 4 [incase y iis null then x will equal to 4]

- want to make error response standered for all error types -> 1. add folder errors in api layer then add class 'apiResponse' دا اللي هيكون جواه شكل الاوبجكت اللي احنا عايزين نعمله ريتيرن في حاله حصل ايرور
															-> 2. in endPoints check if there is error create obj from apiResponse and pass error code to it 